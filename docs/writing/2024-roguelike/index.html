<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="/style.css">
        <title>My definition of a roguelike</title>
    </head>
    <body>
        
<nav>
    <a href="/">Back to homepage</a>
    <a href="/documents">Back to index</a>
</nav>
<main>
    <div id="outline">
<ul>
<li><a href="#my-definition-of-a-roguelike">My definition of a roguelike</a>
<ul>
<li><a href="#being-mechanically-roguelike">Being mechanically roguelike</a></li>
<li><a href="#being-prototypically-roguelike">Being prototypically roguelike</a></li>
</ul>
</li>
</ul>
</div>
<article>
<h1 id="my-definition-of-a-roguelike" tabindex="-1">My definition of a roguelike</h1>
<p>I consider whether a game is roguelike on two axes:</p>
<ul>
<li>How prototypically roguelike is it?<br>
This asks how many characteristic incidental features of <em>Rogue</em> the game shares.<br>
A game can only be prototypically roguelike to some degree—there are no exclusion criteria.</li>
<li>How mechanically roguelike is it?<br>
This asks how many characteristic features that nowadays define the genre the game has.<br>
A game can strictly fail to be mechanically roguelike—there are exclusion criteria.</li>
</ul>
<p>Even if a game is strictly not mechanically rogulike, it may be highly prototypically roguelike.<br>
A game, here, may be a particular configuration of a game, or a game played in a specific manner,
or a specific part of a game.</p>
<h2 id="being-mechanically-roguelike" tabindex="-1">Being mechanically roguelike</h2>
<p>There are three <strong>strict</strong> criteria for being mechanically roguelike.
Failing to meet them excludes a game from being mechanically roguelike.</p>
<ul>
<li>Gameplay can be divided into <em>runs</em>, possibly interspersed by other gameplay.</li>
<li>There is a practically unlimited number of runs.</li>
<li>Runs can end in a defined success or failure state. There may be different types of success or failure.</li>
</ul>
<p>It is possible to classify a game differently depending on how runs are defined.
Often, there is a natural or common notion of runs that is most readily identified,
but sometimes, an interesting different classification is reached by redefining a run.<br>
Here, gameplay is taken to allow for repeated initializations of the game,
and interruption or suspension of the game. Perspectives may also differ in how gameplay
is delimited.</p>
<p>There are two criteria that determine the degree to which a game is mechanically roguelike,
if it satisfies the above strict criteria.</p>
<ul>
<li>A large part of the non-system content of each run is unpredictable.<br>
The more that can be predicted, the less mechanically roguelike.<br>
Predictability from player actions in previous runs detracts more
from being mechanically roguelike than predictability from game-supplied
run content in previous runs, which detracts more from being mechanically
roguelike than predictability which is independent of previous runs.</li>
<li>There is little one can do in any specific run that significantly improves
the likelihood or difficulty of achieving a success state in a following run.<br>
The more that can be done, the easier it is, and the more it improves future runs,
the less mechanically roguelike.<br>
The less can be known about the nature of the effect and the less can be known about
which runs it improves the less it detracts from being mechanically roguelike.<br>
An effect of a similar magnitude in sum that is spread over a large number of runs
(e.g. improves the chance of succeeding within a broader range of runs, but to
the same degree) detracts less from being mechanically roguelike than a focussed effect.<br>
If an effect applies to all future runs (isn’t bounded), it detracts less from
being mechanically roguelike.</li>
</ul>
<h2 id="being-prototypically-roguelike" tabindex="-1">Being prototypically roguelike</h2>
<p>Being prototypically roguelike is an amalgamation of yet more axes.
Here I list named stages per axis in order from most prototypically roguelike to least.
All criteria are more relevant as they apply to the runs
(should the game be mechanically roguelike).</p>
<ul>
<li>Characters
<ul>
<li>There is a single player character.</li>
<li>There are multiple player characters, or there is no player character.</li>
</ul>
</li>
<li>Players
<ul>
<li>There is only one player.</li>
<li>There are multiple players.</li>
</ul>
</li>
<li>Fundamental gameplay context
<ul>
<li>The gameplay involves manipulating actors in a 2D grid.</li>
<li>The gameplay involves manipulating actors in a discretized 2D space.</li>
<li>The gameplay involves manipulating actors in a 2D space.</li>
<li>The gameplay involves manipulating actors in an n-dimensional space.</li>
<li>The gameplay is not best described as manipulating actors in space.</li>
</ul>
</li>
<li>Graphics
<ul>
<li>The game is played in a terminal.</li>
<li>The graphics are a grid of ASCII symbols.</li>
<li>The graphics consist of ASCII or abstract symbols.</li>
<li>The graphics are abstract, geometric, or highly stylized.</li>
<li>The graphics are stylized but clearly representational.</li>
<li>The graphics are highly realistic.</li>
</ul>
</li>
<li>Gameplay actions
<ul>
<li>The game is turn-based.</li>
<li>The game consists mostly of clearly identifiable discrete steps,
each of which has no time limit.</li>
<li>The game consists mostly of clearly identifiable discrete steps.</li>
<li>The game can be paused indefinitely.</li>
<li>The game provides ample time to ignore the game.</li>
<li>The game provides ample time during which the game is not demanding of the player
(if they wish to succeed in a run).</li>
<li>The game is constantly high-stakes or demanding of the player.</li>
</ul>
</li>
<li>Saving
<ul>
<li>There is no usually available method to return to any given previous state,
as long as that state was in some way marked or saved.</li>
<li>There is a usually available method to return to most given previous states,
but it is difficult to access.</li>
<li>There is a usually available method to return to most given previous states.</li>
<li>There is a universal method to return to most given previous states.</li>
<li>You can go back in time.</li>
</ul>
</li>
</ul>
</article>

</main>

    </body>
</html>
