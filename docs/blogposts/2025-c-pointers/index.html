<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="description" content="C array types are weird. In this article I’ll explain what I find weird about them, what I’d do differently, and ramble on a few related things.">
        
        <link rel="stylesheet" href="/style.css">
        <link rel="stylesheet" href="/syntax-highlighting.css">
        <title>
            C array types are weird; and related topics
        </title>
    </head>
    <body>
        <nav id="skip-to-main-content">
    <a href="#main-content">
        Skip to main content (keyboard navigation)
    </a>
</nav>
<nav id="main-navigation">
    <a href="/">
        Back to homepage
    </a>
    <a href="/blogposts">
        Back to index
    </a>
</nav>
<main>
    <nav id="left-comment">
<p><em>There’s no table of contents for this article, it’s not structured yet.</em></p>
</nav>
<article id="main-content">
<p>C array types are weird.</p>
<p>In this article I’ll explain what I find weird about them, what I’d do differently, and ramble on a few related things.</p>
<p>Technically speaking, an array type <code>T[n]</code> (for some <em>n</em>) is distinct from a pointer type <code>T *</code>. A value of type <code>T[n]</code> represents a contiguous sequence of <code>T</code> values in memory, <em>n</em> long.</p>
<p>But you can’t actually refer to values of type <code>T[n]</code>. Any expression that would be of that type is immediately converted to a pointer, type <code>T *</code>, namely a pointer to the first element.</p>
<p>Since the array indexing operator <code>arr[ix]</code> actually operates on pointers, acting like <code>*(arr + ix)</code>, you can basically treat arrays like pointers.</p>
<p>The only (important) instance where this <em>doesn’t</em> happen is in <code>sizeof arr</code>, which returns <code>sizeof(T)</code> × <em>n</em>.</p>
<pre class="language-c"><code class="language-c"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>arr_ptr <span class="token operator">=</span> arr<span class="token punctuation">;</span>
<span class="token class-name">size_t</span> arr_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">size_t</span> ptr_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>arr_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// These may (and likely will) be different</span></code></pre>
<p>Additionally, in function signatures, any array type you give to an argument is actually interpreted as a pointer instead. The <em>n</em> denoting the size is completely discarded. That means that, as an exception to the exception, <code>sizeof arr</code> in a function with an argument <code>T arr[]</code> will <em>not</em> evaluate to <code>sizeof(T)</code> × <em>n</em>.</p>
<pre class="language-c"><code class="language-c"><span class="token class-name">size_t</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">char</span> msg<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Whereas recognition of the inherent dignity"</span><span class="token punctuation">;</span>
<span class="token class-name">size_t</span> msg_size <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">size_t</span> msg_size_in_fn <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// These may (and likely will) be different</span></code></pre>
<p>Interestingly, there’s a second type in C that acts very similar, but doesn’t cause nearly as many problems. That type is functions.</p>
<p>Like arrays, function values immediately coerce to function pointers. Unlike arrays, however, dereferencing a variable that refers to a function, e.g. <code>*fn</code>, does allow you to call that function in the same way as the plain symbol would.</p>
<pre class="language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">(</span><span class="token operator">*</span>foo<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>While writing <code>&amp;arr</code> for an array does actually give you a pointer-to-array type <code>T (*)[n]</code>, <code>&amp;fn</code> is completely equivalent to <code>fn</code>.</p>
<p>Additionally, writing <code>T fn()</code> or <code>T (*fn)()</code> in function argument lists is also the same—the second gets automatically corrected to the first, very much like array types being automatically corrected to pointer types.</p>
<p>Fundamentally, an array type is similar to a struct with all members being of the same type. But arrays are often used in a way that structs aren’t. We rarely get the address of the second member of a struct. This is probably because an array with its head shifted remains an array, just of a different size. Since we often ignore, or are ignorant of, the size of an array, this is a natural way to deal with arrays.</p>
<p>I think it would’ve been much easier to mentally model the situation if C had employed a strict separation of arrays and pointers.</p>
<p>Arrays should act just like structs. Passing a <code>char[5]</code> to a function should pass the actual five values in the array. It should be like having five <code>char</code> arguments to the function.</p>
<p>A pointer to an array would therefore involve only one level of indirection. If you wanted to treat an array like a pointer, you’d have to manually write <code>&amp;arr[0]</code> to get a pointer to the first element of <code>arr</code>.</p>
<p>The most obvious immediate benefit is that this makes the language less confusing to learn. It’s very easy to be confused, as a beginner, by the fact that writing to an array inside a function does change the array outside the function, but the same isn’t true for structs.</p>
<p>Normally, the presence of references makes this delightfully explicit and easy to understand in C. In fact, C is, in this respect, much simpler and easier to understand than languages like Python, where objects are pointers by default, and C++, where an argument may be passed by reference depending on the function signature without any change to the call site.</p>
<p>The most immediate downside is that the arrays are being copied all the time. I don’t think that necessarily detracts from the idea. It would just mean that you have to be smart about using it, and it would give the programmer more choices, not less. (Still not as overwhelmingly many choices as something like C++, in case you’re worried about that)</p>
<p>The compiler could, of course, also choose to implement these arrays using pointers, even selectively, when it suits its purposes. That could leave the more intuitive semantics intact.</p>
<p>But how would you construct such an array from a pointer? Writing <code>(char[3]){*arr, *(arr + 1), *(arr + 2)}</code> would be very tedious indeed. Luckily, there is prior art for this.</p>
<p>GDB, the debugger, has an expression system, and it extends C’s syntax with the <code>@</code> operator, used to imbue a memory address with a length to make it an array.</p>
<p>However, it doesn’t actually take a memory address as its operand. Rather, it acts on expressions like <code>*ptr</code>, which <em>have</em> an address, instead of ones that <em>are</em> an address.</p>
<p>This is analogous to how things like <code>=</code> already work. We can write <code>*ptr = 2</code>, since <code>*ptr</code> is not just a value, but a value with a particular location in memory that can be written to. You cannot write <code>2 = 2</code>. We call these expressions <em>place expressions</em>, or <em>lvalues</em>.</p>
<p>Similarly, you write <code>*ptr@10</code> to get an array whose first element is <code>*ptr</code> and has 9 elements after that. But you cannot write <code>2@10</code>.</p>
<p>I think this is a neat way for this operator to work. It could in theory allow for things like</p>
<pre class="language-c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">coords_3d</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> x<span class="token punctuation">;</span>
	<span class="token keyword">int</span> y<span class="token punctuation">;</span>
	<span class="token keyword">int</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span> some_point<span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">coords_2d</span> <span class="token punctuation">{</span>
	<span class="token keyword">int</span> x<span class="token punctuation">;</span>
	<span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span> some_point_projected <span class="token operator">=</span> some_point<span class="token punctuation">.</span>x@<span class="token number">2</span><span class="token punctuation">;</span></code></pre>
<p>This feels a bit unnatural in this case due to the fact that, unlike arrays, a part of a struct type isn’t really quite as easy to relate to the original struct type. We rarely deal with structs where we know some prefix of them, which might be analogous to an array where we don’t know the size.</p>
<p>The way in which we understand arrays of unknown size as a pointer is, in fact, an example of a broader pattern, where we hide some object we can’t deal with directly behind some opaque handle. Then, we have some way of supplying the missing information to actually operate on the object.</p>
<p>In a C array, that missing information may be the length, which is then supplied from any number of sources.</p>
<p>We may store that information alongside the array, either in memory, next to the array, but at a static offset, or alongside the pointer in our local variables.</p>
<p>Storing it together with the pointer in our local variables is what we call a wide pointer. This is e.g. how <code>std::vector</code> in C++ may be implemented, and it’s what Rust uses automatically to let you take references to unsized types like arrays, <code>&amp;[T]</code>, that automatically store their length.</p>
<p>We’re effectively already doing this in C whenever we take parameters like <code>size_t len, char *buf</code>.  Taking two arguments is equivalent to taking a two-member struct, and that two-member struct, if we were to extract it as its own type, is a wide pointer.</p>
<p>Storing that additional data in memory just before the actual data is what e.g. C++ derived classes with virtual methods do. <sup><a href="#footnote-1" id="footnote-1-ref-1">Footnote 1</a></sup></p>
<p>Getting back to my improved C arrays, you could therefore convert back and forth like this:</p>
<pre class="language-c"><code class="language-c"><span class="token keyword">char</span> arr<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token char">'x'</span><span class="token punctuation">,</span> <span class="token char">'y'</span><span class="token punctuation">,</span> <span class="token char">'z'</span><span class="token punctuation">,</span> <span class="token char">'w'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>arr_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> arr_again<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">*</span>arr_ptr@<span class="token number">4</span><span class="token punctuation">;</span></code></pre>
<p>Slicing an array is very natural in this syntax:</p>
<pre class="language-c"><code class="language-c"><span class="token keyword">int</span> iota<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> one_two<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> iota<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>@<span class="token number">2</span><span class="token punctuation">;</span></code></pre>
<p>Obviously, it would be equally possible to have the syntax <code>ptr@n</code> instead, without needing the dereference. You could still write something like <code>(&amp;iota[2])@3</code>. I think it looks less nice though, and gives you less insight about how place expressions and the like work.</p>
<p>One problem is that you have to know the length. If you’re just shifting the beginning of the array, you write:</p>
<pre class="language-c"><code class="language-c"><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
arr <span class="token operator">=</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>@<span class="token number">1</span><span class="token punctuation">;</span></code></pre>
<p>But that requires stating the new length explicitly. If you have some kind of operator to get the array size defined like <code>sizeof(arr)/sizeof(T)</code>, you could use that. It’s tedious and ugly nonetheless.</p>
<p>The three obvious solutions are to either allow <code>arr + 1</code>, or to automatically infer the length with a special syntax, e.g. <code>arr[1]@...</code>, or to make a new custom operator, e.g. <code>arr +@ 1</code>.</p>
<p>Since I can’t actually redesign C, and I’m not currently writing a new language, and this probably isn’t that common, I’ll give no specific recommendation.</p>
<p>As a last note, I’ll mention the <code>-&gt;</code> operator. That one is similar to the <code>@</code> operator in that whether it deals in pointers or place expressions is kind of arbitrary.</p>
<p>Right now, the expression <code>ptr-&gt;foo</code> denotes <em>the value</em> <code>(*ptr).foo</code>, with a dereference included for free. To get the address, you write <code>&amp;ptr-&gt;foo</code>. But it could’ve just as easily been defined as <code>&amp;(*ptr).foo</code>. Then, to get the value, you’d write <code>*ptr-&gt;foo</code>.</p>
<p>Right now, to get nested values from pointers to structs, you write <code>ptr-&gt;foo.bar</code>. With the alternate <code>-&gt;</code>, you’d write <code>ptr-&gt;foo-&gt;bar</code> (for the pointer).</p>
<p>One might say that <code>ptr-&gt;foo.bar</code> shows that there’s only actually one pointer being followed, and <code>ptr-&gt;foo</code> isn’t itself a pointer. But the alternate syntax would show that too, since you’d write <code>*ptr-&gt;foo-&gt;bar</code> to actually get at the value.</p>
<p>This is a very ill-substantiated feeling, and possibly entirely wrong, but I have a very slight preference for <code>ptr-&gt;foo-&gt;bar</code>. Working entirely in the realm of pointers is, to me, slightly more reflective of the fact that the compiler only actually has to apply one offset.</p>
<p>But <code>ptr-&gt;foo.bar</code> is more reflective of the neat interplay between place expressions, the dereference operator, and the address-of operator. Since I praised that so much above, perhaps that feeling is hypocritical.</p>
<aside id="footnotes">
<h2> Footnotes </h2>
<ol>
<li id="footnote-1">
<p>See <a href="https://www.youtube.com/watch?v=wU8hQvU8aKM">this video by YouTuber Logan Smith on C++ and Rust's dynamic dispatch</a> for more details on this topic.
<a href="#footnote-1-ref-1">Go back to text</a></p>
</li>
</ol>
</aside>
</article>

</main>


    </body>
</html>
